"""
Prompt模板类
包含系统图表绘制Agent的所有Prompt模板
"""

from typing import Dict, Any


class PromptTemplates:
    """系统图表绘制Agent的Prompt模板集合"""
    
    # 1. 需求理解模块 Prompt
    REQUIREMENT_UNDERSTANDING = """
你是一个专业的系统分析师，擅长理解用户的系统需求。请分析用户提供的信息，识别并提取以下关键信息：

**分析任务：**

1. **用户意图识别**：用户想要绘制什么类型的图表？

2. **系统类型判断**：这是什么类型的系统（Web应用、数据库系统、移动应用、企业系统等）？

3. **核心需求提取**：用户希望通过图表展示什么？

4. **细节完整性评估**：用户提供的信息是否足够绘制图表？

**输出格式：**

```json
{
"图表类型": "需要绘制的图表类型",
"系统类型": "系统的分类",
"核心需求": "用户的主要需求描述",
"关键要素": ["要素1", "要素2", "要素3"],
"信息完整度": "完整/部分完整/不完整",
"补充问题": ["需要进一步了解的问题1", "问题2"]
}
```

**用户输入：**

{用户的需求描述}

请基于以上框架进行分析。
"""

    # 2. 系统理解模块 Prompt
    SYSTEM_UNDERSTANDING = """
你是一个资深的系统架构师，请深入分析用户描述的系统，提取绘图所需的核心信息。

**分析维度：**

### 2.1 实体分析（适用于E-R图、类图）

- **主要实体/类**：识别系统中的核心实体

- **属性信息**：每个实体的关键属性

- **关系类型**：实体间的关联关系（一对一、一对多、多对多）

### 2.2 功能分析（适用于用例图、功能结构图）

- **参与者角色**：系统的用户类型

- **核心功能**：系统提供的主要功能

- **功能层次**：功能的组织结构和层级关系

### 2.3 流程分析（适用于流程图、时序图、活动图）

- **业务流程**：关键业务操作的执行步骤

- **交互对象**：参与交互的对象或模块

- **时间顺序**：操作的时间先后关系

- **条件分支**：流程中的判断和分支逻辑

### 2.4 架构分析（适用于系统架构图、协作图）

- **系统组件**：主要的系统模块或服务

- **技术架构**：系统的技术层次（表现层、业务层、数据层）

- **部署结构**：系统的部署方式和环境

- **通信机制**：组件间的交互方式

**输出要求：**

根据用户描述的系统，提取与目标图表类型相关的信息，格式化输出便于后续绘图使用。

**用户系统描述：**

{用户的系统描述}

**目标图表类型：**

{从需求理解模块获得的图表类型}

请进行深入分析并结构化输出。
"""

    # 3.1 系统E-R图绘制Prompt
    ER_DIAGRAM = """
基于提供的系统信息，绘制系统E-R图。请遵循以下规范：

**绘制规则：**

- 矩形表示实体，实体名称用名词

- 椭圆表示属性，主键属性用下划线标注

- 菱形表示关系，关系名称用动词

- 连线表示实体与关系的联系

- 标注关系的类型（1:1, 1:N, M:N）

**输出格式：**

使用Mermaid语法绘制E-R图：

```mermaid
erDiagram
实体A {
属性1 类型
属性2 类型 PK
}
实体B {
属性1 类型
属性2 类型
}
实体A ||--o{ 实体B : 关系名称
```

**系统信息：**

{从系统理解模块获得的实体、属性、关系信息}

请绘制完整的E-R图。
"""

    # 3.2 UML类图绘制Prompt
    CLASS_DIAGRAM = """
基于提供的系统信息，绘制UML类图。请遵循以下规范：

**绘制规则：**

- 类用矩形表示，包含类名、属性、方法

- 关联用实线连接

- 依赖用虚线箭头

- 继承用带空心三角的实线箭头

- 实现用带空心三角的虚线箭头

- 聚合用带空心菱形的实线

- 组合用带实心菱形的实线

**输出格式：**

使用Mermaid语法绘制类图：

```mermaid
classDiagram
class 类名A {
-私有属性 : 类型
+公有属性 : 类型
+方法名() 返回类型
}
类名A --> 类名B : 关系类型
```

**系统信息：**

{从系统理解模块获得的类、属性、方法、关系信息}

请绘制完整的类图。
"""

    # 3.3 UML用例图绘制Prompt
    USE_CASE_DIAGRAM = """
基于提供的系统信息，绘制UML用例图。请遵循以下规范：

**绘制规则：**

- 参与者用小人图标表示

- 用例用椭圆表示

- 参与者与用例间用直线连接

- 用例间可有包含(include)、扩展(extend)关系

- 系统边界用矩形框表示

**输出格式：**

请详细描述用例图的组成，并说明各元素间的关系。

**系统信息：**

{从系统理解模块获得的参与者、用例、关系信息}

请绘制完整的用例图描述。
"""

    # 3.4 流程图绘制Prompt
    FLOWCHART = """
基于提供的系统信息，绘制系统流程图。请遵循以下规范：

**绘制规则：**

- 开始/结束用椭圆表示

- 处理步骤用矩形表示

- 判断/分支用菱形表示

- 流程方向用箭头表示

- 确保逻辑清晰，无死循环

**输出格式：**

使用Mermaid语法绘制流程图：

```mermaid
flowchart TD
A[开始] --> B{判断条件}
B -->|是| C[处理步骤1]
B -->|否| D[处理步骤2]
C --> E[结束]
D --> E
```

**系统信息：**

{从系统理解模块获得的业务流程信息}

请绘制完整的流程图。
"""

    # 3.5 时序图绘制Prompt
    SEQUENCE_DIAGRAM = """
基于提供的系统信息，绘制系统时序图。请遵循以下规范：

**绘制规则：**

- 纵向表示时间流向

- 横向表示参与交互的对象

- 生命线用虚线表示

- 同步消息用实线箭头

- 返回消息用虚线箭头

- 激活条表示对象处理活动的时段

**输出格式：**

使用Mermaid语法绘制时序图：

```mermaid
sequenceDiagram
participant A as 对象A
participant B as 对象B
A->>B: 消息1
B-->>A: 返回消息1
A->>B: 消息2
```

**系统信息：**

{从系统理解模块获得的交互对象、消息流信息}

请绘制完整的时序图。
"""

    # 3.6 活动图绘制Prompt
    ACTIVITY_DIAGRAM = """
基于提供的系统信息，绘制系统活动图。请遵循以下规范：

**绘制规则：**

- 椭圆表示开始节点

- 带黑点的圆表示结束节点

- 矩形框表示具体活动

- 菱形表示条件判断

- 可使用泳道划分职责

- 支持并行和分支逻辑

**输出格式：**

详细描述活动图的结构，包括活动节点、判断节点、并行分支等。

**系统信息：**

{从系统理解模块获得的活动流程、条件判断信息}

请绘制完整的活动图描述。
"""

    # 3.7 协作图绘制Prompt
    COLLABORATION_DIAGRAM = """
基于提供的系统信息，绘制系统协作图。请遵循以下规范：

**绘制规则：**

- 对象框表示参与交互的对象

- 连线表示对象间的关联关系

- 带编号的箭头表示消息传递顺序

- 强调对象间的静态连接结构

- 展示消息流和职责分配

**输出格式：**

详细描述协作图的对象、关联关系、消息传递顺序。

**系统信息：**

{从系统理解模块获得的对象、关联、消息信息}

请绘制完整的协作图描述。
"""

    # 3.8 功能结构图绘制Prompt
    FUNCTION_STRUCTURE_DIAGRAM = """
基于提供的系统信息，绘制整体功能结构图。请遵循以下规范：

**绘制规则：**

- 采用自上而下的树状结构

- 顶层表示系统总体功能

- 逐层细化为子功能模块

- 框图表示功能单元

- 连接线表示层级关系

**输出格式：**

使用文字描述功能结构的层次关系，或使用简单的树状图。

**系统信息：**

{从系统理解模块获得的功能模块、层次关系信息}

请绘制完整的功能结构图。
"""

    # 3.9 系统架构图绘制Prompt
    SYSTEM_ARCHITECTURE_DIAGRAM = """
基于提供的系统信息，绘制系统架构图。请遵循以下规范：

**绘制规则：**

- 矩形或图标表示系统组件

- 箭头表示数据流或调用关系

- 体现层次结构（表现层、业务层、数据层）

- 展示部署结构和技术选型

- 明确组件边界和交互方式

**输出格式：**

详细描述系统架构的各个层次、组件、以及它们之间的关系。

**系统信息：**

{从系统理解模块获得的系统组件、架构层次、技术信息}

请绘制完整的系统架构图描述。
"""

    # 4. 质量检查模块 Prompt
    QUALITY_CHECK = """
请对生成的图表进行质量检查，确保图表的准确性和完整性：

**检查维度：**

1. **逻辑一致性**：图表逻辑是否合理，无矛盾

2. **完整性**：是否包含了用户需求的所有关键元素

3. **规范性**：是否符合相应图表的绘制规范

4. **可读性**：图表是否清晰易懂

5. **准确性**：是否准确反映了用户的系统

**输出格式：**

```json
{
"质量评分": "1-10分",
"检查结果": {
"逻辑一致性": "通过/不通过 + 说明",
"完整性": "通过/不通过 + 说明",
"规范性": "通过/不通过 + 说明",
"可读性": "通过/不通过 + 说明",
"准确性": "通过/不通过 + 说明"
},
"改进建议": ["建议1", "建议2", "建议3"]
}
```

**待检查图表：**

{生成的图表内容}

**原始需求：**

{用户的原始需求}

请进行全面的质量检查。
"""

    # 5. 交互优化模块 Prompt
    INTERACTION_OPTIMIZATION = """
基于用户反馈和系统分析结果，优化交互体验：

**优化任务：**

1. **信息补全**：如果用户信息不完整，生成精准的补充问题

2. **结果解释**：为生成的图表提供清晰的解释说明

3. **替代方案**：如果当前图表不满足需求，提供其他图表类型建议

4. **细节调整**：根据用户反馈调整图表细节

**交互策略：**

- 使用友好、专业的语调

- 提供具体、可操作的建议

- 避免技术术语过多，保持通俗易懂

- 主动询问用户是否需要进一步调整

**当前状态：**

{当前的分析结果和图表状态}

**用户反馈：**

{用户的反馈意见}

请提供优化建议和下一步行动方案。
"""

    # 6. 主控制器模块 Prompt
    MAIN_CONTROLLER = """
你是系统图表绘制Agent的主控制器，负责协调各个模块的工作流程：

**工作流程：**

1. 接收用户输入 → 启动需求理解模块

2. 需求分析完成 → 启动系统理解模块

3. 系统分析完成 → 启动对应的图表绘制模块

4. 图表生成完成 → 启动质量检查模块

5. 质量检查完成 → 启动交互优化模块

6. 根据用户反馈决定是否需要重新生成或调整

**决策逻辑：**

- 信息不完整 → 请求用户补充信息

- 需求不明确 → 提供选项让用户选择

- 多种图表适用 → 推荐最佳选择并说明原因

- 生成失败 → 分析原因并提供替代方案

**当前任务：**

{当前的任务状态和用户输入}

请协调各模块完成任务，并提供清晰的执行步骤。
"""

    @classmethod
    def get_prompt(cls, prompt_type: str, **kwargs) -> str:
        """
        获取指定类型的prompt模板
        
        Args:
            prompt_type: prompt类型
            **kwargs: 模板变量
        
        Returns:
            格式化后的prompt字符串
        """
        prompt_map = {
            "requirement_understanding": cls.REQUIREMENT_UNDERSTANDING,
            "system_understanding": cls.SYSTEM_UNDERSTANDING,
            "er_diagram": cls.ER_DIAGRAM,
            "class_diagram": cls.CLASS_DIAGRAM,
            "use_case_diagram": cls.USE_CASE_DIAGRAM,
            "flowchart": cls.FLOWCHART,
            "sequence_diagram": cls.SEQUENCE_DIAGRAM,
            "activity_diagram": cls.ACTIVITY_DIAGRAM,
            "collaboration_diagram": cls.COLLABORATION_DIAGRAM,
            "function_structure_diagram": cls.FUNCTION_STRUCTURE_DIAGRAM,
            "system_architecture_diagram": cls.SYSTEM_ARCHITECTURE_DIAGRAM,
            "quality_check": cls.QUALITY_CHECK,
            "interaction_optimization": cls.INTERACTION_OPTIMIZATION,
            "main_controller": cls.MAIN_CONTROLLER
        }
        
        template = prompt_map.get(prompt_type)
        if not template:
            raise ValueError(f"未知的prompt类型: {prompt_type}")
        
        try:
            return template.format(**kwargs)
        except KeyError as e:
            raise ValueError(f"缺少必要的模板变量: {e}")
    
    @classmethod
    def get_diagram_prompt(cls, diagram_type: str, system_info: str) -> str:
        """
        根据图表类型获取对应的绘制prompt
        
        Args:
            diagram_type: 图表类型
            system_info: 系统信息
        
        Returns:
            格式化后的绘制prompt
        """
        diagram_prompt_map = {
            "E-R图": "er_diagram",
            "UML类图": "class_diagram",
            "UML用例图": "use_case_diagram",
            "流程图": "flowchart",
            "时序图": "sequence_diagram",
            "活动图": "activity_diagram",
            "协作图": "collaboration_diagram",
            "功能结构图": "function_structure_diagram",
            "系统架构图": "system_architecture_diagram"
        }
        
        prompt_type = diagram_prompt_map.get(diagram_type)
        if not prompt_type:
            raise ValueError(f"不支持的图表类型: {diagram_type}")
        
        return cls.get_prompt(prompt_type, **{"从系统理解模块获得的实体、属性、关系信息": system_info,
                                           "从系统理解模块获得的类、属性、方法、关系信息": system_info,
                                           "从系统理解模块获得的参与者、用例、关系信息": system_info,
                                           "从系统理解模块获得的业务流程信息": system_info,
                                           "从系统理解模块获得的交互对象、消息流信息": system_info,
                                           "从系统理解模块获得的活动流程、条件判断信息": system_info,
                                           "从系统理解模块获得的对象、关联、消息信息": system_info,
                                           "从系统理解模块获得的功能模块、层次关系信息": system_info,
                                           "从系统理解模块获得的系统组件、架构层次、技术信息": system_info})
    
    @classmethod
    def list_supported_diagrams(cls) -> Dict[str, str]:
        """
        获取支持的图表类型列表
        
        Returns:
            图表类型字典
        """
        return {
            "E-R图": "实体关系图，用于数据库设计",
            "UML类图": "类图，用于面向对象设计",
            "UML用例图": "用例图，用于需求分析",
            "流程图": "业务流程图，用于流程梳理",
            "时序图": "时序图，用于交互设计",
            "活动图": "活动图，用于活动流程",
            "协作图": "协作图，用于对象协作",
            "功能结构图": "功能结构图，用于功能分解",
            "系统架构图": "系统架构图，用于架构设计"
        } 